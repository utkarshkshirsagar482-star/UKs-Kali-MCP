from mcp.server.fastmcp import FastMCP
import subprocess
import shlex
import asyncio

# Initialize FastMCP server
mcp = FastMCP("PentestTools")

@mcp.tool()
async def execute_command(command: str) -> str:
    """
    Executes a shell command on the system.
    WARNING: Use with caution. This allows arbitrary command execution.
    """
    try:
        # Split command for safety, but we are running in shell=True to support pipes/redirection if needed
        # However, for security, using list is better, but user asked for "all tools", so shell might be needed.
        # We will use shell=True to allow flexibility (e.g., nmap -sV ... | grep ...)
        # In a real secure environment, this is bad practice.
        proc = await asyncio.create_subprocess_shell(
            command,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )

        try:
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=60)
            if proc.returncode == 0:
                return stdout.decode()
            else:
                return f"Error executing command: {stderr.decode()}"
        except asyncio.TimeoutError:
            try:
                proc.kill()
                await proc.communicate()
            except:
                pass
            return "Command timed out."

    except Exception as e:
        return f"Unexpected error: {str(e)}"

@mcp.tool()
async def run_python_script(script_content: str) -> str:
    """
    Executes a python script provided as a string.
    """
    try:
        proc = await asyncio.create_subprocess_exec(
            "python3", "-c", script_content,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )

        try:
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=30)
            if proc.returncode == 0:
                return stdout.decode()
            else:
                return f"Error: {stderr.decode()}"
        except asyncio.TimeoutError:
            try:
                proc.kill()
                await proc.communicate()
            except:
                pass
            return "Execution timed out."

    except Exception as e:
        return f"Execution failed: {str(e)}"

@mcp.tool()
async def nmap_scan(target: str, arguments: str = "-F") -> str:
    """
    Runs an Nmap scan against a target.
    Default arguments: -F (Fast scan)
    """
    # Sanitize input slightly to prevent easy chaining if we weren't using shell=False (but subprocess handles list well)
    cmd = ["nmap"] + shlex.split(arguments) + [target]
    try:
        proc = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )

        try:
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=120)
            return stdout.decode()
        except asyncio.TimeoutError:
            try:
                proc.kill()
                await proc.communicate()
            except:
                pass
            return "Nmap scan timed out."

    except Exception as e:
        return f"Nmap scan failed: {str(e)}"

if __name__ == "__main__":
    mcp.run()
